# 그림으로 배우는 HTTP&NetWork

## 제 1장 웹과 네트워크의 기본에 대해 알아보자

### 1.1 웹은 HTTP로 나타낸다

+ 웹 브라우저는 웹브라우저 주소 입력란에 지정된 URL에 의지해서 웹 서버로부터 리소스라고 불리는 파일 등의 정보를 얻는다.
+ 클라이언트에서 서버까지 일련의 흐름을 결정하고 있는 것은 웹에서 HTTP(HyperText Transfer Protocol)이라 불리는 프로토콜이다.
+ 프로토콜이라는 의미는 "약속"이다.
+ HTTP/1.1 : 현재 가장 많이 사용되는 버전

### 1.3.2 계층으로 관리하는TCP/IP
+ TCP/IP : 인터넷과 관련된 프로토콜들을 모은 것
  - TCP/IP는 애플리케이션 계층, 트랜스포트 계층, 네트워크 계층, 링크 계층 이렇게 4계층으로 나뉘어있다.
  - 계층화 이유 : 1. 사양이 변경된 계층만 바꿀 수 있다
                  2. 각 계층은 계층이 연결되어 있는 부분만 결정되어 있어, 각 계층의 내부는 자유롭게 설계할 수 있다.
                  3. 계층화하면 설계를 편하게 할 수 있다.
+ 애플리케이션 계층
  - 유저에게 제공되는 애플리케이션에서 사용하는 통신의 움직임을 결정
  - FTP랑 DNS, HTTP 도 애플리케이션 계층에 포함
+ 트랜스포트 계층
  - 트랜스포트 계층은 애플리케이션 계층에 네트워크로 접속되어 있는 2대의 컴퓨터 사이의 데이터 흐름을 제공
  - TCP / UDP 두가지 프로토콜 존재
+ 네트워크 계층(인터넷 계층)
  - 네트워크 상에서 패킷의 이동을 다룹니다.
  - 패킷이란 전송하는 데이터의 최소단위
  - 어떤 경로를 거쳐 상대방의 컴퓨터까지 패킷을 보낼지를 결정
+ 링크 계층(데이터 링크 계층, 네트워크 인터페이스 계층)
  - 네트워크에 접속하는 하드웨어적인 면을 다룹니다.
  - 운영체제가 하드웨어를 제어하기 때문에 디바이스 드라이버랑 네트워크 인터페이스 카드를 포함
  - 케이블과 같이 물리적으로 보이는 부분도 포함

### 1.3.3 TCP/IP 통신의 흐름
+ 송신하는 측은 애플리케이션 계층에서부터 내려가고, 수신하는 측은 애플리케이션 계층으로 올라갑니다.
+ 순서(송신) : 송신측 클라이언트의 애플리케이션 계층(HTTP)에서 어느 웹 페이지를 보고 싶다라는 HTTP 리퀘스트를 지시, 
그 다음에 있는 트랜스포트계층(TCP)에서 애플리케이션계층에서 받은 데이터를 통신하기 위해 조각내어 안내번호와 포트를 붙여
네트워크계층에 전달, 네트워크 계층(IP)에서는 수신지 MAC주소를 추가해서 링크 계층으로 전달
+ 순서(수신) : 수신 측 서버는 링크 계층에서 데이터를 받아들여 순서대로 위의 계층에 전달하여 애플리케이션 계층까지 도달

+ 송신할떄 각 계층을 거칠때 , 해당 계층마다 필요한 정보를 추가 반대로 수신측에서 각 계층을 거칠 떄마다 사용한 헤더를 삭제 이를 **캡슐화 라고함**

### 1.4.1 배송을 담당하는 IP
+ IP : 인터넷 프로토콜 /  IP주소(IP Address) : 각 노드에 부여된 주소
+ IP의 역할은 개개의 패킷을 상대방에게 전달하는 것
+ 상대방에게 전달하기까지 IP주소와 MAC주소라는 요소가 중요
+ ARP(Address Resolution Protocol)이라는 프로토콜을 이용하여 다음 중계할 곳의 MAC주소를 사용하여 목적지를 찾아간다. 

### 1.4.2 신뢰성 있는 TCP
+ 바이트 스트림 서비스 : 용량이 큰 데이터를 보내기 쉽게 TCP 세그먼트라고 불리는 단위 패킷으로 작게 분해하여 관리하는 것

#### Three way handshaking
+ SYN 플래그 : 송신측에서 접속함과 동시에 패킷을 보냄
+ SYN/ACK 플래그 : 수신측에서 SYN/ACK 플래그로 송신측에 접속함과 동시에 패킷을 수신한 사실을 전한다.
+ 마지막으로 송신측이 'ACK'플래그를 보내 패킷 교환이 완료되었음을 전한다.

### 1.5 이름 해결을 담당하는 DNS


### 1.7 URI와 URL
+ URL(Uniform Resource Locator)
+ URI(Uniform Resource Identifiers) 

##### Uniform
통일(Uniformity)된 서식을 결정하는 것으로, 여러 가지 종류의 리소스 지정 방법을 같은 맥락에서 구별없이 취급

또한, 새로운스키마 http와 ftp 등 도입을 용이하게 한다.

##### Resource

리소스는 '식별 가능한 모든 것'이라고 정의 되어 있습니다. 도큐먼트 파일뿐만 아니라 이미지와 서비스 등 다른 것과 구별할 수 있는
것은 모두 리소스 입니다. 또한 리소스는 단일한 부분만 아니라 복수의 집합도 리소스로 파악할 수 있습니다.

##### Identifier
식별 가능한 것을 참조하는 오브젝트이며 식별자로 불립니다. 결국 URI는 스키마를 나타내는 리소스를 식별하기 위한 식별자 입니다.

URI는 리소스를 식별하기 위해 문자열 전반을 나타내는데 비해 URL은 리소스의 장소(네트워크 상의 위치)를 나타냅니다.
URL은 URI의 서브셋입니다.

## 제2장 간단한 프로토콜 HTTP

### 2.3 HTTP는 상태를 유지하지 않는 프로토콜

+ HTTP는 상태를 계속 유지하지 않는 스테이트리스(stateless) 프로토콜 입니다.
+ 리퀘스트와 리스폰스를 교환하는 동안에 상태를 관리하지 않습니다. 즉, HTTP프로토콜 레벨에서는 이전에 보냈던 리퀘스트나
이미 되돌려준 리스폰스에 대해서는 전혀 기억하지 않습니다.
+ 상태를 계속 유지하고 싶은 요구에 부응하기 위해서 쿠키(Cookie)라는 기술이 도입되었습니다.

### 2.4 리퀘스트 URI로 리소스를 식별
+ HTTP는 URI(Uniform Resource Identifiers)를 사용하여 인터넷 상의 리소스를 지정합니다.

### 2.5 서버에 임무를 부여하는 HTTP 메소드

#### GET
+ get 메소드는 리퀘스트 URI로 식별된 리소스를 가져 올 수 있도록 요구합니다.

#### Post
+ Post메소드는 엔티티를 전송하기 위해서 사용됩니다.
+ Post는 Get과 비슷하지만 리스폰스에 의한 엔티티를 획득하는 것만이 목적은 아닙니다.

#### Put
+ Put 메소드는 파일을 전송하기 위해서 사용됩니다.
+ FTP에 의한 파일 업로드와 같이, 리퀘스트 중에 포함된 엔티티를 리퀘스트 URI로 지정한 곳에 보존하도록 요구합니다.

#### Head
+ Head메소드는 Get과 같은 기능이지만 메시지 바디를 돌려주지 않습니다.
+ URI 유효성과 리소스 갱신 시간을 확인하는 목적 등으로 사용됩니다.

#### DELETE 
+ DELETE메소드는 파일을 삭제하기 위해 사용됩니다.
+ Put메소드와 반대로 동작합니다.

#### OPTIONS
+ OPTIONS메소드는 리퀘스트 URI로 지정한 리소스가 제공하고 있는 메소드를 조사하기 위해 사용

#### TRACE
+ TRACE메소드는 Web서버에 접속해서 자신에게 통신을 되돌려 받는 루프백을 발생시킵니다.
+ 클라이언트는 TRACE메소드를 사용함으로써, 리퀘스트를 보낸 곳에 어떤 리퀘스트가 가공되어 있는지 등을 조사할 수 있습니다.

#### Connect
+ Connect 메소드는 프록시에 터널 접속 확립을 요함으로써, TCP 통신을 터널링 시키기 위해서 사용합니다.

### 2.8 쿠키를 사용한 상태 관리
+ 무상태 프로토콜(Stateless)를 보안하기 위해 탄생

## 제3장 HTTP정보는 HTTP 메시지에 있다.

+ HTTP 메시지는 메시지 헤더와 메시지 바디로 구성되어있다.
+ 리퀘스트 메시지 헤더 : 리퀘스트 라인, 리퀘스트 헤더 필드, 일반 헤더 필드. 엔티티 헤더 필드
+ 리스폰스 메시지 헤더 : 상태 라인, 리스폰스 헤더 필드, 일반 헤더 필드, 엔티티 헤더 필드르

+ 리퀘스트 라인 : 리퀘스트에 사용하는 메소드와 리퀘스트 URI와 사용하는 HTTP 버전이 포함
+ 상태 라인 : 리스폰스 결과를 나타내는 상태 코드와 설명, 사용하는 HTTP 버전이 포함
+ 헤더 필드 : 리퀘스트와 리스폰스의 여러 조건과 속성등을 나타내는 각 헤더 필드가 포함

#### 3.3.1 메시지 바디와 엔티티 바디의 차이

+ 메시지 : HTTP 통신의 기본 단위로 옥텟 시퀀스로 구성되고 통신을 통해서 전송됩니다.
+ 엔티티 : 리퀘스트랑 리스폰스의 페이로드(부가물)로 전송되는 정보로 엔티티 헤더 필드와 엔티티 바디로 구성됩니다.

+ 멀티파트 : 여러 다른 종류의 데이터를 수용
+ 리줌(resume) : 다운로드하다가 끈기면 끈긴 지점부터 다운로드 재개할 수 있다.
+ 레인지 리퀘스트 : 위 기능을 실현하기위해 범위를 지정하여 리퀘스트 하는 것

### 3.6 최적의 콘텐츠를 돌려주는 콘텐츠 네고시에이션
+ 구글 웹 페이지에서는 영어와 한국어와 같이 서로 다른언어를 주로 사용하는 브라우저가 같은 URI에 액세스할 때에
각각 영어판 웹 페이지와 한국어판 웹 페이지를 표시합니다. 이와 같은 구조를 콘텐츠 네고시에이션이라고 부릅니다.
+ 콘텐츠 네고시에이션은 제공하는 리소스를 언어와 문사 세트, 인코딩 방식 등을 기준으로 판단

##### 콘텐츠 네고시에이션에는 다음과 같은 종류들이 있다.
+ 서버 구동형 네고시에이션(Server-driven Negotiation) : 서버 측에서 콘텐츠 네고시에이션 하는 방식
+ 에이전트 구동형 네고시에이션(Agent-driven Negotiation) : 클라이언트 측에서 콘텐츠 네고시에이션 하는 방식
+ 트랜스페어런트 네고시에이션(Transparent Negotitation) : 서버 구동형과 에이전트 구동형을 혼합한 방식

## 제 4장 결과를 전달하는 상태 코드

> 리스폰스의 클래스는 다음과 같이 5개가 정의
+ 1xx : informational 클래스, 리퀘스트를 받아들여 처리중
+ 2xx : Success 클래스, 리퀘스트를 정상적으로 처리 했음
+ 3xx : Redirection 클래스, 리퀘스트를 완료하기 위해서 추가 동작이 필요
+ 4xx : Client Error클래스, 서버는 리퀘스트 이해 불가능
+ 5xx : Server Error클래스, 서버는 리퀘스트 처리 실패

#### 4.2 2xx 성공
+ 200 : 성공
+ 204 : 리퀘스트 성공, 하지만 돌려줄 리소스가 없다.
+ 206 : 부분 지정된 범위의 엔티티가 포함

#### 4.3 3xx 리다이렉트
+ 301 : 새로운 URI가 부여되어 있다.
+ 302 : 301과 달리 일시적
+ 303 : 302과 같은 기능이지만 Get메소드로 얻어야 한다.
+ 304 : 리소스는 있지만 조건이 맞지않는 경우

#### 4.4 4xx 클라이언트 에러
+ 400 : 잘못된 리퀘스트
+ 401 : 인증이 필요
+ 403 : 엑세스 거부 (권한)
+ 404 : 서버상에 없다.

#### 4.5 5xx 서버 에러
+ 500 : 리퀘스트를 처리하는 도중 에러가 발생
+ 503 : 서버 과부하

## 제5장 HTTP와 연계하는 웹 서버

+ 가상 호스트라는 기능을 통해 1대의 서버에서 여러 도매인을 가질 수 있다.

### 5.2 통신을 중계하는 프로그램

+ 프록시 : 서버와 클라이어트의 양쪽 역할을 하는 중계 프로그램으로, 클라이언트로부터의 리퀘스트를 서버에 전송하고, 서버로부터의 리스폰스를
클라이언트에 전송합니다.

+ 게이트웨이 : 다른 서버를 중계하는 서버로, 클라이언트로부터 수신한 리퀘스트를 리소스를 보유한 서버인 것처럼 수신합니다. 경우에 따라서
클라이언트는 상대가 게이트웨이라는 것을 알지 못하는 경우도 있습니다.

+ 터널 : 서로 떨어진 두 대의 클라이언트와 서버 사이를 중계하며 접속을 주선하는 중계 프로그램입니다.

### 5.2.1 프록시
+ 프록시 서버를 사용하는 이유는 나중에 설명할 캐시를 사용해서 네트워크 대역등을 표율적으로 사용하는 것과 조직 내에 특정 웹사이트에 대한
액세스 제한, 액세스 로그를 획득하는 정책을 지키려는 목적

##### 프록시의 사용 방법 2가지
+ 캐시하는지 안하는지 여부
+ 메시지를 변경하는지 안하는지 여부

+ 캐싱 프록시 : 프록시 서버상에 리소스 캐시를 보존해 두는 타입의 프록시
  - 프록시에 같은 리소스에 대한 리퀘스트가 온 경우, 오리진 서버로부터 리소스를 획득하는 것이 아닌 캐시를 리스폰스로 돌려주는 것
+ 투명 프록시 : 중계할 때 메시지를 변경하지 않는 타입의 프록시

### 5.2.2 게이트웨이
+ HTTP 서버 이외의 서비스를 제공하는 서버
+ 클라이언트와 게이트웨이 사이를 암호화하는 등으로 하게 접속함으로써 통신의 안전성을 높이는 역할

### 5.2.3 터널
+ 터널은 요구에 따라 다른 서버와의 통신 경로를 확립
+ 클라이언트는 SSL과 같은 암호화 통신을 통해 서버와 안전하게 통신을 하기 위해 사용
+ 터널자체는 HTTP 리퀘스트를 해석 X

### 5.3 리소스를 보관하는 캐시
+ 캐시는 프록시 서버와 클라이언트의 로컬 디스크에 보관된 리소스의 사본을 가르킨다.
+ 캐시를 사용하면 리소스를 가진 서버에의 액세스를 줄일 수 있다.
+ 캐시서버는 프록시 서버의 하나로 캐싱 

### 5.3.2 클라이언트 측에도 캐시가 있다.
+ 인터넷 익스플로러에서 클라이언트가 보존하는 캐시를 인터넷 임시 파일이라고 부릅니다.

## 제6장 HTTP헤더

### 6.1 HTTP 메시지 헤더
+ 메시지 헤더 : 클라이언트와 서버 처리에 필요한 주요 정보가 거의 다 여기에 있다.
+ 메시지 바디 : 사용자와 리소스를 필요로 하는 정보가 있다.

> 리퀘스트의 HTTP 메시지는 메소드, URI, HTTP 버전, HTTP 헤더필드로 구성

> 리스폰스의 HTTP 메시지는 HTTP 메시지와, HTTP 버전, 상태코드, HTTP 헤더필드로 구성

### 6.2.4 4종류의 HTTP 헤더필드

+ 일반적 헤더 필드(General Header Fields) : 리퀘스트 메시지와 리스폰스 메시지 둘 다 사용되는 헤더입니다.
+ 리퀘스트 헤더 필드(Request Header Fields) : 클라이언트 측에서 서버 측으로 송신된 리퀘스트 메시지에 사용되는 헤더로 리퀘스트의 부가적 정보, 리스폰스의 콘텐츠에 관한 우선 순위등을 부가합니다.

+ 리스폰스 헤더 필드(Response Header Fields) : 서버 측에서 클라이언트 측으로 송신한 리스폰스 메시지에 사용되는 헤더로 리스폰스의 정보와 서버의 정보, 클라이언트의 추가 정보 요구 등을 부가합니다.
+ 엔티티 헤더 필드(Entitiy Header Fields) : 리퀘스트 메시지와 리스폰스 메시지에 포함된 엔티티에 사용되는 헤더로 콘텐츠 갱신 시간 등의 엔티티에 관한 정보를 부가합니다.

### 6.2.6 End-to-end 헤더 와 Hop-by-hop 헤더

+ End-to-end 헤더 : 리퀘스트나 리스폰스의 최종 수신자에게 전송된다. 캐시에서 구축된 리스폰스 중 보존되야 하고, 다시 전송되지 않으면 안되도록 되어 있다.
+ Hop-by-hop 헤더 : 이 카테고리에 분류된 헤더는 한 번 전송에 대해서만 유효하고 캐시와 프록시에 의해서 전송되지 않는 것도 있습니다. 
HTTP/1.1과 그 이후에서 사용되는 Hop-by-hop 헤더는 Connection헤더 필드에 열거해야 합니다.

> 아래 열거하는 8개 헤더필드 이외에는 모두 End-by-end (즉 아래는 hop-by-hop)
+ Connection
+ Keep-Alive
+ Porxy-Authenticate
+ Proxy-Authorization
+ Trailer
+ TE
+ Transfer-Encoding
+ Upgrade



### > 일반 헤더 필드

### 6.3.2 Connection
Connection 헤더 필드는 다음의 두 가지 역할을 합니다.
+ 프록시에 더 이상 전송하지 않는 헤더 필드를 지정
+ 지속적 접속 관리

### 6.3.4 Pragma
Pragma 헤더필드는 HTTP/1.1 보다 오래된 버전의 흔적으로 HTTP/1.0와의 후방 호환성만을 위해서 정의되어 있는 헤더필드입니다.

### 6.3.5 Trailer
Trailer 헤더 필드는 메시지 바디의 뒤에 기술되어 있는 헤더 필드를 미리 전달할 수 있습니다.

### 6.3.6 Transfer-Encoding
Transfer-Encoding 헤더 필드는 메시지 바디의 전송 코딩 형식을 지정하는 경우에 사용됩니다.

chunked 란?  / 사전적 의미 : 덩어리, 상당히 많은 / 전체 데이터가 아닌 덩어리로 쪼개진 상태의 데이터를 의미

### 6.3.7 Upgrade
Upgrade 헤더 필드는 HTTP 및 다른 프로토콜의 새로운 버전이 통신에 이용되는 경우에 사용됩니다.

### 6.3.8 Via
Via 헤더 필드는 클라이언트와 서버 간의 리퀘스트 혹은 리스폰스 메시지의 경로를 알기 위해서 사용
프록시 혹은 게이트웨이는 자신의 서버 정보를 Via헤더 필드에 추가한 뒤에 메시지를 전송

### 6.3.9 Warning
Warning 헤더는 HTTP/1.0 리스폰스 헤더(Retry-After)가 HTTP/1.1에서 변경된 것으로, 리스폰스에 관한 추가 정보를 전달
기본적으로 캐시에 관한 문제의 경고를 전달

### 6.4.1 Accept
Accept 헤더 필드는 유저 에이전트에 처리할 수 있는 미디어 타입과 미디어타입의 상대적인 우선순위를 전달하기 위해서 사용됩니다.
미디어 타입의 지정은 타입/서브 타입으로서 한번에 여러 번 설정할 수 있습니다.

### 6.4.2 Accept-Charset
Accept-Charset 헤더 필드는 유저 에이전트에서 처리할 수 있는 문자셋으로, 문자셋의 상대적인 우선 순위를 전달하기 위해서 사용됩니다.
또한, 문자셋은 한번에 여러개를 지정할 수 있습니다.

### 6.4.3 Accept-Encoding
Accept-Encoding 헤더 필드는 유저 에이전트가 처리할 수 있는 콘텐츠 코딩과 콘텐츠 코딩의 상대적인 우선 순위를 전달하기 위해서 사용됩니다.

> 콘텐츠 코딩은 다음과 같은 것들이 있습니다.
+ gzip : 파일 압축 프로그램 gzip에서 생성된 인코딩 포맷으로 Lempel-Ziv 부호와 32비트 CRC를 사용
+ compress : Unix 파일 압축 프로그램 "compress"에의해 만들어진 인코딩 포맷
+ deflate : Zlib 포맷과 deflate 압축 알고리즘에 의해 만들어진 인코딩 포맷을 조합
+ identity : 압축과 변형을 하지 않는 디폴트 인코딩 포맷

### 6.4.4 Accept-Language
Accept-Language 헤더 필드는 유저 에이전트가 처리할 수 있는 자연어의 세트와 자연어 세트의 상대적인 우선 순위를 전달하기 위해서 사용됩니다.

### 6.4.5 Authorization
Authorization 헤더필드는 유저 에이전트의 인증 정보를 전달하기 위해서 사용합니다.

### 6.4.6 Expect
Expect헤더 필드는 클라이언트가 서버에 특정한 동작 요구를 전달합니다.

### 6.4.7 From
From 헤더 필드는 유저 에이전트를 사용하고 있는 유저의 메일 주소를 전달합니다.

### 6.4.8 Host
Host 헤더필드는 리퀘스트한 리소스의 인터넷 호스트와 포트 번호를 전달합니다.

### 6.4.9 If-Match
If-xxx 라는 서식의 리퀘스트 헤더 필드는 조건부 리퀘스트라고 부릅니다.
조건부 리퀘스트를 받은 서버는 지정된 조건에 맞는 경우에만 리퀘스트를 받습니다.

### 6.4.10 If-Modified-Since
If-Modified-Since 헤더 필드는 조건부 리퀘스트의 하나로 리소스가 갱신날짜가 필드값보다 새롭지 않다면 리퀘스트를 받아들이겠다는
뜻을 전달합니다.

..... (이하 생략)

### > 6.5 리스폰스 헤더 

### 6.5.1 Accept-Range
Accept-Ranges 헤더 필드는 서버가 리소스의 일부분만 지정해서 취득할 수 있는 Range 리퀘스트를 접수할 수 있는지 여부를 전달합니다.

### 6.5.2 Age
Age 헤더 필드는 얼마나 오래 전에 오리진 서버에서 리스폰스가 생성되었는지를 전달합니다.

### 6.5.3 ETag
ETag 헤더 필드는 엔티티 태크라고 불리며 일의적으로 리소스를 특정하기 위한 문자열을 전달합니다.

### 6.5.4 Location
Location 헤더필드는 리스폰스의 수신자에 대해서 Request-URI 이외의 리소스 액세스를 유도하는 경우에 사용됩니다.

### 6.5.5 Proxy-Authenticate
Proxy-Authenticate 헤더필드는 프록시 서버에서의 인증 요구를 클라이언트에 전달합니다.

### 6.5.6 Retry-After
Retry-After 헤더 필드는 클라이언트가 일정 시간 후에 리퀘스트를 다시 시행해야 하는지를 전달합니다.

### 6.5.7 Server
Server 헤더필드는 서버에 설치되어 있는 HTTP 서버의 소프트웨어를 전달합니다.

### 6.5.8 Vary
Vary 헤더필드는 캐시를 컨트롤하기 위해서 사용합니다.

### > 6.6 엔티티 헤더 필드

### 6.6.1 Allow
Allow 헤더필드는 Request-URI에 지정된 리소스가 제공한 메소드의 일람을 전달합니다.

### 6.6.2 Content-Encoding
Content-Encoding 헤더 필드는 서버가 엔티티 바디에 대해서 실시한 콘텐츠 코딩 형식을 전달합니다.
콘텐츠 코딩은 엔티티의 정보가 누락되지 않도록 압축할 것을 지시합니다.

### 6.6.6 Content-MD5
Content-MD5 헤더필드는 메시지 바디가 변경되지 않고 도착했는지 확인하기 위해 MD5알고리즘에 의해 생성된 값을 전달합니다.

### 6.6.8 Content-Type
Content-Type 헤더 필드는 엔티티 바디에 포함되는 오브젝트의 미디어 타입을 전달합니다.

### 6.7 쿠키를 위한 헤더 필드
서버와 클라이언트 간의 상태를 관리하는 쿠키는 HTTP/1.1의 사양인 RFC2616에 포함된 것은 아니지만 웹 사이트에서 널리 사용
쿠키는 유저 식별과 상태관리에 사용되고 있는 기능입니다.
웹 사이트가 유저의 상태를 관리하기 위해서 웹 브라우저 경유로 유저의 컴퓨터 상에 일시적으로 데이터를 기록해 두고, 다음에 그 유저가 웹 사이트에 액세스 해 왔을 때 지난번에 발행한 쿠키를 송신받을 수 있습니다.
쿠키가 호출되엇을 때는 쿠키의 유효 기한과 송신지의 도메인, 경로, 프로토콜 등을 체크하는 것이 가능하기 때문에, 적절하게 발행된 쿠키는 다른 웹 사이트와 공격자의 공격에 의해 데이터가 도난당하는 일은 없습니다.

> 쿠키와 관련된 헤더필드

### 6.7.1 Set-Cookie

1. Expires 속성 : 쿠키의 Expires 속성은 브라우저가 쿠키를 송출 할 수 있는 유효기한을 지정
2. Path 속성 : 쿠키의 Path 속성은 쿠키를 송출하는 범위를 특정 디렉토리에 한정할 수 있습니다.
3. Domian 속성 : 쿠키의 domain 속성에 의해서 지정된 도메인 명은 후방 일치가 된다.
4. Secure 속성 : 쿠키의 secure 속성은 웹페이지가 HTTPS에서 열렸을 떄에만 쿠키 송출을 제한하기 위해서 지정합니다.
5. HTTPOnly 속성 : 쿠키의 HttpOnly 속성은 자바스크립트를 경유해서 쿠키를 취득하지 못하도록 하는 쿠키의 확장 기능입니다.

### 6.7.2 Cookie

Cookie 헤더 필드는 클라이언트가 HTTP의 상태 관리 지원을 원할 때 서버로부터 수신한 쿠키를 이후의 리퀘스트에 포함해서 전달합니다.

### 6.8 그 이외의 헤더 필드
+ X-Frame-Option
+ X-XSS-Protection
+ DNT
+ P3P

## 제 7장 웹을 안전하게 지켜주는 HTTPS

### 7.1 HTTP의 약점

+ 평문(암호화 하지 않은) 통신이기 때문에 도청가능
  - TCP/IP는 도청 가능한 네트워크
  - 암호화로 도청을 피하다
    - 통신 암호화 : HTTP에는 암호화 구조는 없지만 SSL(Secure Socket Layer)이나 TLS(Transport Layer Security)라는 다른 프로토콜을 조합함으로 써 HTTP의 통신 내용을 암호화 할 수 있습니다.
    - 콘텐츠 암호화 : 통신하고 있는 콘텐츠의 내용 자체를 암호화해 버리는 방법
+ 통신 상대를 확인하지 않기때문에 위장 가능
  - 누구나 리퀘스트할 수 있다.
  - 상대를 확인하는 증명서
+ 완전성을 증명할 수없기 때문에 변조가능
  - 수신한 내용이 다를지도 모른다.

### 7.2 HTTP + 암호화 + 인증 + 완전성 보호 = HTTPS
+ HTTP에 암호화나 인증 등의 구조를 더한 것을 HTTPS(HTTP Secure)라고 부릅니다.

### 7.2.2 HTTPS는 SSL의 껍질을 덮어쓴 HTTP

+ 보통 HTTP는 직접 TCP와 통신하지만 SSL을 사용한 경우에는 HTTP는 SSL와 통신하고 SSL이 TCP와 통신하게 됩니다. 즉, SSL이라는 껍질을 덮어쓴
HTTP가 HTTPS인 것입니다.

+ SSL은 HTTP와는 독립된 프로토콜로 HTTP만으로는 애플리케이션 계층에서 동작하는 SMTP나 Telnet등에서도 이용될 수 있습니다.

### 7.2.3 상호간에 키를 교환하는 공개키 암호화 방식
+ SSL에서는 공개키 암호화 방식이라 불리는 암호화 방식을 채용

+ 두 개의 키를 사용하는 공개키 암호
  - 공통키 암호의 문제를 해결하려고 한 것이 공개키 암호화라는 방식입니다.
  - 공개키 암호에서는 서로 다른 두 개의 키 페어(쌍)을 사용합니다. 한 쪽은 비밀키라 부르고 다른 한 쪽은 공개키라고 부릅니다. 비밀키는 누구에게도 
  알려지면 안되는 키이며 공개키는 누구에게나 알려져도 괜찮은 키입니다.
  - 암호를 보내는 측이 상대의 공개키를 사용해 암호화를 합니다. 그리고 암호화된 정보를 받아들인 상대는 자신의 비밀키를 사용해 복호화를 실시합니다. 이방식은 암호를 푸는 비밀키를 토인으로 보낼 필요가 없기 때문에 도청에 의해서 키를 빼앗길 걱정은 없습니다.

+ 공개키 암호는 공통키 암호에 비해서 처리속도가 느립니다. 그래서 각각의 방식을 조합해서 통신합니다.

+ 키를 교환하는 곳에서는 공개키 암호를 사용하고 그 후의 통신에서 메시지를 교환하는 곳에서는 공통키 암호를 사용합니다.

## 제 8장 누가 액세스하고 있는지를 확인하는 인증

### HTTP에서 사용하는 인증방법
1. BASIC 인증
2. DIGEST 인증
3. SSL 클라이언트 인증
4. 폼 베이스 인증

## 제 9장 HTTP에 기능을 추가한 프로토콜

HTTP사양에 따른 병목현상
1. 1개의 커넥션으로 1개의 리퀘스트만 보낼 수 있다.
2. 리퀘스트는 클라이언트에서만 시작할 수 있다. 리스폰스만 받는 것은 불가능하다.
3. 리퀘스트/리스폰스 헤더를 압축하지 않은채로 보낸다. 헤더의 정보가 많을수록 지연이 심해진다.
4. 장황한 헤더를 보낸다. 매번 같은 헤더를 보내느 것은 낭비다.
5. 데이터 압축을 임의로 선택할 수 있다. 압축해서 보내는 것이 강제적이지는 않다.

### 병목현상 해결

#### Ajax에 의한 해결방법
+ 웹페이지의 일부분만 고쳐쓸수있는 비동기 통신 방법이다. 기존의 동기식 통신에 비해서 페이지의 일부만 갱신되기 떄문에 리스폰스로 전송되는 데이터 양이 줄어든다는 장점이 있습니다.

#### Comet에 의한 해결 방법
+ Comet은 서버 측의 콘텐츠에 갱신이 있었을 경우, 클라이언트로부터 리퀘스트를 기다리지 않고 클라이언트에 보내기 위한 방법

#### SPDY
SPDY는 HTTP가 안고 있던 병목현상을 프로토콜 레벨에서 해소하기 위해 개발이 진행되고 있는 프로토콜입니다.

SPDY는 HTTP를 완전히 바꿔 놓는 것이 아니라 TCP/IP의 애플리케이션 계층과 트랜스포트 계층 사이에 새로운 세션 계층을 추가하는 형태로 동작합니다.

SPDY를 사용하면 다음과 같은 기능을 HTTP에 추가할 수 있습니다.
+ 다중화 스트림
+ 리퀘스트의 우선 순위 부여
+ HTTP헤더 압축
+ 서버 푸시 기능
+ 서버 힌트 기능

#### WebSocket 프로토콜의 주요 특징
+ 서버 푸시 기능
+ 통신량의 삭감
+ 핸드쉐이크/리퀘스트
+ 핸드 쉐이크/리스폰스

### 9.5 WebDav
WebDav(Web-based Distributed Authoring and Versioning)는 웹 서버의 콘텐츠에 대해서, 직접 파일 복사나 편집 작업 등을 할 수 있는
분산 파일 시스템으로 HTTP/1.1를 확장한 프로토콜로 RFC4918로서 정의되어 있습니다.

### 왜 HTTP는 이렇게 까지 사용되고 있는가?
과거 네트워크를 이용한 시스템이나 소프트웨어를 새로 만들 때에는 필요한 기능을 구현한 새로운 프로토콜을 만드는 경우가 있었습니다. 그러나 최근에는 HTTP를 사용하는 쪽이 대부분입니다. 많은 이유 중의 하나로는 기업이나 조직 등의 방화벽 설정과 관련있습니다.
방화벽의 기본 기능중에 지정된 프로토콜이나 포트 번호 이외의 패킷은 통과시키지 않는다는 기능이 있어 이로 인해 새로운 프로토콜이나 포트번호를 이용하는 경우에는 설정을 변경할 필요가 생깁니다. FTP나 SSH등이 허가되지 않더라도 웹으로 액세스 가능한 회사가 대부분일 것입니다.
웹은 HTTP에서 동작하고 있기 떄문에 웹서버의 구축할 때나 웹사이트에의 액세스에는 방화벽의 설정에서 HTTP(80)나 HTTPS(443)을 허가해 둘 필요가 있습니다.

## 제 10장 웹 콘텐츠에서 사용하는 기술
평상시에 보고있는 웹페이지 대부분은 HTML이 사용되고 있다. HTML로 쓰여진 문서를 브라우저가 해석해서 렌더링(Rendering)처리를 한 결과가
웹 페이지에 표시됩니다.

### 10.2.2 HTML을 조작하기 쉽게 해주는 DOM
DOM(document Object Model)은 HTML문서와 xml문서를 위한 api입니다. DOM을 사용하면 html내의 요소를 오브젝트로 다룰수 있기 때문에
요소 내의 문자열을 추출하거나 css를 프로퍼티로 변경해 디자인을 변경할 수 있습니다. DOM을 사용하게 되면 JavaScript등의 스크립트를
사용하여 HTML을 쉽게 조작할 수 있습니다.

### 10.3.2 웹 서버와 프로그램을 연계하는 CGI
CGI(Common Gateway Interface)는 웹 서버가 클라이언트에서 받은 리퀘스트를 프로그램에 전달하기 위한 구조입니다.
CGI에 의해 프로그램은 리퀘스트 내용에 맞게 HTML을 생성하는 등으로 동적으로 콘텐츠를 생설할 수 있습니다.
CGI는 Perl이나 PHP, Ruby, C언어 등의 프로그래밍 언어가 사용

### 10.3.3 Java에서 보급된 서블릿
서블릿(Servlet)은 서버 상에 HTML 등의 동적 콘텐츠를 생성하기 위한 프로그램을 가리킨다.
위에 소개한 CGI는 리퀘스트마다 프로그램을 기동하기 때문에 대량으로 액세스가 있을 떄 웹 서버에 부하가 걸리게 되지만
서블릿에서는 웹 서버와 같은 프로세스 속에서 동작하기 때문에 비교적 부하를 적게하여 동작시킬 수 있다.

## 제 11장 웹 공격 기술 

### 11.1.1 HTTP에는 보안 기능이없다.

### 11.1.3 웹 어플리케이션에 대한 공격 패턴
1. 능동적 공격
2. 수동적 공격

##### 서버를 노리는 능동적 공격
+ 능동적 공격은 공격자가 직접 웹 어플리케이션에 액세스해서 공격 코드를 보내는 타입의 공격이빈다.
대표적으로 SQL 인젝션과 OS커맨드 인젝션등이 있습니다.

##### 유저를 노리는 수동적 공격
+ 수동적 공격은 함정을 이용해서 유저에게 공격코드를 실행시키는 공격입니다.

### 11.2.2 SQL 인젝션
+ SQL 인젝션(SQL Injection)이란 웹 어플리케이션을 이용하고 있는 데이터베이스에 SQL을 부정하게 실행하는 공격입니다.

### 11.2.3 OS 커맨드 인젝션
+ OS 커맨드 인젝션(OS Command Injection)이란 웹 어플리케이션을 경유하여 OS명령을 부정하게 실행하는 공격입니다.

### 11.2.4 HTTP 헤더 인젝션
+ HTTP 헤더 인젝션(HTTP Header Injection)이란 공격자가 리스폰스 헤더필드에 개행문자등을 삽입함으로써 임의의 리스폰스 헤더 필드나
바디를 추가하는 수동적 공격입니다. 특히 바디를 추가하는 공격을 HTTP 리스폰스 분할공격이라고 부릅니다.

